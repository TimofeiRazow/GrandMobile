# GrandMobile - Сервис-ориентированная архитектура

## Обзор архитектуры

Проект был рефакторен с удалением `GameManager` антипаттерна в пользу чистой сервис-ориентированной архитектуры. Теперь игровая логика разделена на отдельные сервисы, которые общаются через события.

## Основные компоненты

### 1. CoreLoop - Основной игровой цикл
**Файл:** `Assets/Codebase/Controllers/CoreLoop.cs`

Центральный координатор игрового процесса, который:
- Инициализирует все сервисы
- Управляет жизненным циклом игры
- Координирует взаимодействие между сервисами
- Подписывается на события сервисов для реагирования на изменения

**Ключевые методы:**
- `Start()` - Запуск игры
- `Update()` - Основной цикл обновления
- `RestartGame()` - Перезапуск игры
- `PauseGame()`/`ResumeGame()` - Пауза/продолжение

### 2. GamePhaseService - Управление фазами игры
**Файл:** `Assets/Codebase/Infrastructure/Services/GamePhaseService.cs`

Управляет сменой игровых фаз (День → Ночь → Голосование):
- Автоматическая смена фаз по таймеру
- События изменения фаз
- Настраиваемая длительность фаз

**События:**
- `PhaseChanged` - Смена фазы
- `PhaseTimeUpdated` - Обновление оставшегося времени
- `GameMessage` - Игровые сообщения

### 3. CharacterLifecycleService - Управление персонажами
**Файл:** `Assets/Codebase/Infrastructure/Services/CharacterLifecycleService.cs`

Отслеживает состояние всех персонажей:
- Регистрация/удаление персонажей
- Отслеживание убийств и смертей
- Поиск персонажей по критериям
- Статистика по ролям

**События:**
- `CharacterRegistered` - Регистрация персонажа
- `CharacterKilled` - Смерть персонажа
- `CharacterAttacked` - Атака персонажа
- `RoleCountChanged` - Изменение количества ролей

### 4. TaskProgressService - Управление задачами
**Файл:** `Assets/Codebase/Infrastructure/Services/TaskProgressService.cs`

Отслеживает выполнение задач:
- Автоматическое обнаружение задач на сцене
- Отслеживание прогресса задач
- Подсчет общего прогресса
- Поиск задач по критериям

**События:**
- `TaskRegistered` - Регистрация задачи
- `TaskCompleted` - Завершение задачи
- `TaskProgressChanged` - Изменение прогресса
- `OverallProgressChanged` - Изменение общего прогресса
- `AllTasksCompleted` - Все задачи выполнены

### 5. GameWinConditionService - Проверка условий победы
**Файл:** `Assets/Codebase/Infrastructure/Services/GameWinConditionService.cs`

Автоматически проверяет условия победы:
- Победа мафии (количество >= остальных)
- Победа полиции (мафия уничтожена)
- Победа мирных (все задачи выполнены)

**События:**
- `GameWon` - Игра окончена
- `WinConditionChecked` - Проверка условий (отладка)

### 6. ActionObjectProvider - Управление объектами взаимодействия
**Файл:** `Assets/Codebase/Infrastructure/Services/ActionObjectProvider.cs`

Централизованный провайдер для поиска объектов:
- Кэширование объектов по ролям и типам
- Эффективный поиск ближайших объектов
- Автоматическая регистрация объектов

## Паттерны архитектуры

### 1. Event-Driven Architecture
Все сервисы общаются через события, что обеспечивает:
- Слабую связанность компонентов
- Легкую расширяемость
- Возможность подписки на события из любой части кода

### 2. Service-Oriented Architecture
Каждый сервис отвечает за одну область:
- Единственная ответственность
- Независимость от других сервисов
- Возможность замены реализации

### 3. Dependency Injection
Все зависимости внедряются через Zenject:
- Легкое тестирование
- Контроль времени жизни объектов
- Автоматическое разрешение зависимостей

## Интеграция с AI

### AI состояния подписываются на события сервисов:

**AiIdleState** реагирует на:
- `GamePhaseService.PhaseChanged` - Адаптирует поведение к фазе игры
- Ночью мафия становится активнее
- Во время голосования все менее активны

**Остальные состояния** могут подписаться на:
- `CharacterLifecycleService.CharacterKilled` - Реакция на смерти
- `TaskProgressService.TaskCompleted` - Реакция на выполненные задачи

## Запуск игры

### Последовательность инициализации:

1. **GameplaySceneRoot** создает CoreLoop через DI
2. **CoreLoop.Start()** инициализирует:
   - Создание персонажей через CharacterViewFactory
   - Регистрацию персонажей в CharacterLifecycleService
   - Обнаружение задач через TaskProgressService.DiscoverTasks()
   - Запуск первой фазы через GamePhaseService.StartDay()
3. **Сервисы** начинают отслеживать состояние и генерировать события
4. **AI состояния** реагируют на события и адаптируют поведение

## Конфигурация

### ProjectInstaller.cs
Регистрирует все сервисы как синглтоны:
```csharp
Container.Bind<GamePhaseService>().AsSingle();
Container.Bind<CharacterLifecycleService>().AsSingle();
Container.Bind<TaskProgressService>().AsSingle();
Container.Bind<GameWinConditionService>().AsSingle();
Container.Bind<ActionObjectProvider>().AsSingle();
```

## Преимущества новой архитектуры

### 1. Масштабируемость
- Легко добавлять новые сервисы
- Простое расширение функциональности
- Независимое развитие компонентов

### 2. Тестируемость
- Каждый сервис можно тестировать изолированно
- Mock-объекты для зависимостей
- Четкие интерфейсы и контракты

### 3. Maintainability
- Логика разделена по областям ответственности
- Легко находить и исправлять баги
- Понятная структура кода

### 4. Производительность
- Эффективное кэширование в ActionObjectProvider
- Событийная модель без постоянных проверок
- Ленивые вычисления где возможно

## Отладка

### Логирование
Все сервисы содержат подробное логирование:
- Изменения состояния
- События и реакции на них
- Статистика и метрики

### Методы отладки
```csharp
// Статистика персонажей
characterLifecycleService.LogStatistics();

// Статистика задач
taskProgressService.LogStatistics();

// Статистика объектов
actionObjectProvider.LogStats();

// Принудительная победа (для тестов)
gameWinConditionService.ForceWin(WinCondition.MafiaWins);
```

## Заключение

Новая архитектура обеспечивает:
- ✅ Отсутствие God Object (GameManager)
- ✅ Четкое разделение ответственности
- ✅ Слабую связанность компонентов
- ✅ Высокую тестируемость
- ✅ Легкую расширяемость
- ✅ Event-driven communication
- ✅ Правильное использование DI

Архитектура готова к дальнейшему развитию и добавлению новых функций без нарушения существующего кода. 